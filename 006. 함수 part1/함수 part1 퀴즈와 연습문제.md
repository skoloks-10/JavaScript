# 함수 part1 퀴즈와 연습문제

## 퀴즈

## 문제 1. JavaScript에서 함수에 대한 올바른 설명은 무엇일까요?

**선택지**

A. 함수는 오직 문자열 데이터만 다룰 수 있는 실행 단위이다.

B. 함수는 일련의 실행문을 하나로 묶은 코드 블록이며, 입력을 받고 결과를 반환하는 일급 객체이다.

C. 함수는 반드시 입력 값을 받아야 하며, 입력이 없으면 실행할 수 없다.

D. 함수는 단순히 숫자 계산만을 처리하는 순수한 계산 도구이다.

**정답**: B

**해설**:

JavaScript에서 함수는 여러 문장을 하나의 실행 단위로 캡슐화한 코드 블록입니다. 입력(인수)을 받아 처리한 후, 결과(반환값)를 돌려주며 상수, 변수, 객체 등 다른 값처럼 취급할 수 있는 **일급 객체**입니다. 함수는 입력이 없더라도 실행될 수 있으며, 다양한 작업(계산, 데이터 처리 등)을 수행합니다.

---

## 문제 2. 함수 선언문과 함수 표현식의 가장 큰 차이는 무엇인가요?

**선택지**

A. 함수 선언문은 함수 이름을 생략할 수 있지만, 함수 표현식은 반드시 이름이 있어야 한다.

B. 함수 선언문은 코드 실행 전에 **호이스팅(hoisting)** 되어 호출할 수 있으나, 함수 표현식은 변수 초기화 이후에만 사용할 수 있다.

C. 함수 선언문은 항상 반환값이 있어야 하지만, 함수 표현식은 반환값이 없어도 된다.

D. 함수 선언문은 오직 전역 스코프에서만 정의할 수 있고, 함수 표현식은 로컬 스코프에서만 정의할 수 있다.

**정답**: B

**해설**:

함수 선언문은 스크립트 로딩 시점에서 전체 코드 영역에 걸쳐 **호이스팅** 되므로, 선언문 이전에도 호출할 수 있습니다. 반면, 함수 표현식은 변수의 선언만 호이스팅되고, 함수 객체의 할당은 실행 순서에 따르기 때문에 할당 이후에야 호출이 가능합니다.

---

## 문제 3. 다음 코드의 출력 결과는 무엇일까요?

```jsx
console.log(add(2, 5));

function add(x, y) {
  return x + y;
}

```

**선택지**

A. 7

B. undefined

C. TypeError

D. ReferenceError

**정답**: A

**해설**:

이 코드는 함수 선언문을 사용하여 함수를 정의했습니다. 함수 선언문은 호이스팅 되므로, `add` 함수는 코드 실행 전에 이미 할당되어 있습니다. 따라서 `add(2, 5)`를 호출하면 올바르게 7을 반환합니다.

---

## 문제 4. 다음 코드의 실행 결과는 무엇일까요?

```jsx
console.log(sub(2, 5));

var sub = function(x, y) {
  return x - y;
};

```

**선택지**

A. -3

B. undefined

C. TypeError: sub is not a function

D. ReferenceError: sub is not defined

**정답**: C

**해설**:

여기서는 함수 표현식을 사용하여 함수를 정의했습니다. 변수 `sub`는 **호이스팅**에 의해 선언만 되지만 초기화는 대입문이 실행될 때 이루어집니다. 그러므로 `console.log`가 실행되는 시점에서는 `sub`가 아직 함수 객체로 할당되지 않았고, 기본값인 `undefined`인 상태입니다. 결과적으로 `undefined`에 함수 호출을 시도하므로 **TypeError: sub is not a function** 에러가 발생합니다.

---

## 문제 5. 화살표 함수(Arrow Function)의 특징에 대한 설명 중 옳지 않은 것은 무엇인가요?

**선택지**

A. 화살표 함수는 항상 익명 함수로 정의된다.

B. 화살표 함수는 더 간결한 문법을 제공하여 코드의 가독성을 높인다.

C. 화살표 함수는 자체적인 `this` 바인딩을 갖지 않고, 상위 스코프의 `this`를 그대로 사용한다.

D. 화살표 함수는 일반 함수 선언문에서의 호이스팅과 동일하게 동작한다.

**정답**: D

**해설**:

화살표 함수는 익명 함수로 작성되며, 간결한 문법과 상위 스코프의 `this` 바인딩을 그대로 사용한다는 장점이 있습니다. 그러나 **호이스팅**의 경우, 화살표 함수는 함수 표현식과 유사하게 동작하여 변수 호이스팅만 발생하고 함수 정의 자체는 실행 시점에 평가됩니다. 그러므로 함수 선언문처럼 코드 시작 전에 완전히 준비되어 있지 않습니다. 따라서 선택지 D는 옳지 않은 설명입니다.

---

## 연습문제

## 문제 1. 함수 선언문 작성하기

**문제**

두 개의 숫자를 입력받아 그 합을 반환하는 함수 `add`를 함수 선언문 방식으로 작성하세요.

**예상 출력**

```jsx
console.log(add(3, 4)); // 7

```

**해설**

함수 선언문은 `function` 키워드를 사용하여 함수 이름과 매개변수를 정의합니다. 선언문은 전체 스코프에서 **호이스팅(hoisting)** 되므로, 선언 이전에도 호출할 수 있습니다.

**예시 답안**

```jsx
function add(x, y) {
  return x + y;
}

```

---

## 문제 2. 함수 표현식 작성하기

**문제**

두 개의 숫자를 입력받아 그 차이를 반환하는 함수 `sub`를 함수 표현식 방식으로 작성하세요.

**예상 출력**

```jsx
console.log(sub(10, 3)); // 7

```

**해설**

함수 표현식은 보통 익명 함수(anonymous function)를 변수에 할당하여 사용합니다. 변수 호이스팅는 발생하지만, 초기화(함수 객체 할당)는 코드 실행 시점에 진행되므로, 선언문보다 늦게 호출해야 합니다.

**예시 답안**

```jsx
var sub = function(x, y) {
  return x - y;
};

```

---

## 문제 3. Function 생성자 사용하기

**문제**

Function 생성자(constructor)를 사용하여 두 개의 숫자를 곱하는 함수 `multiply`를 작성하세요.

**예상 출력**

```jsx
console.log(multiply(3, 5)); // 15

```

**해설**

Function 생성자는 매개변수 목록과 함수 몸체를 문자열로 전달받아 함수 객체를 생성합니다. 동적으로 함수를 생성할 수 있지만, 가독성과 성능 면에서 다른 방식보다 권장되지는 않습니다.

**예시 답안**

```jsx
var multiply = new Function('x', 'y', 'return x * y');

```

---

## 문제 4. 화살표 함수 작성하기

**문제**

화살표 함수를 이용하여 두 숫자의 나눗셈 결과를 반환하는 함수 `divide`를 작성하세요. (단, y는 0이 아닌 것으로 가정합니다.)

**예상 출력**

```jsx
console.log(divide(10, 2)); // 5

```

**해설**

화살표 함수는 간결한 문법을 제공하며 항상 익명 함수로 생성됩니다. 또한, 자신만의 `this` 바인딩을 갖지 않고 상위 스코프의 `this`를 그대로 사용합니다.

**예시 답안**

```jsx
const divide = (x, y) => x / y;

```

---

## 문제 5. 호이스팅 이해하기

**문제**

아래 코드를 실행할 때 예상되는 출력 결과를 작성하세요.

```jsx
console.log(foo(10, 20));
console.log(bar(10, 20));

function foo(x, y) {
  return x + y;
}

var bar = function(x, y) {
  return x * y;
};

```

**예상 출력 및 해설**

- `console.log(foo(10, 20));` → **30**
    - 함수 선언문인 `foo`는 호이스팅 되므로, 선언 이전에도 정상적으로 호출이 가능합니다.
- `console.log(bar(10, 20));` → **TypeError: bar is not a function**
    - 변수 `bar`는 호이스팅에 의해 선언은 되었으나, 초기화(함수 객체 할당)는 실행 시점에 이뤄집니다.
    - 따라서 해당 시점에서는 `bar`의 값이 `undefined`인 상태이고, `undefined`를 함수처럼 호출하려고 하면 에러가 발생합니다.

---

## 문제 6. 기명 함수 표현식과 익명 함수 표현식의 차이

**문제**

다음 코드를 보고, 내부에서 함수 이름을 참조하는 것과 외부에서 참조하는 것의 차이를 설명하세요.

```jsx
var test = function foo(x) {
  if (x > 0) {
    return foo(x - 1) + x;
  }
  return 0;
};

console.log(test(3));
// console.log(foo(3)); // 주석을 해제하면 어떤 오류가 발생할지 작성하세요.

```

**예상 답변 및 해설**

- `test(3)`을 호출하면 함수 내부의 `foo`가 재귀 호출되어 올바르게 계산됩니다.
    - 계산 과정: `foo(3) = foo(2) + 3`, `foo(2) = foo(1) + 2`, `foo(1) = foo(0) + 1`, `foo(0) = 0`
    - 따라서 전체 결과는 `0 + 1 + 2 + 3 = 6`이 됩니다.
- 외부에서 `foo(3)`를 호출하면 **ReferenceError: foo is not defined**가 발생합니다.
    - 함수 표현식에서 사용된 기명 함수 `foo`의 이름은 오직 함수 몸체 내부에서만 접근할 수 있는 식별자입니다.

---

## 문제 7. 익명 함수와 기명 함수 표현식 비교

**문제**

다음 코드를 분석하고, 왜 `bar()`를 호출하는 부분에서 에러가 발생하는지 설명하세요.

```jsx
var func = function bar() {
  console.log("Inside bar");
};
func(); // 정상 호출
bar();  // 호출 시 오류 발생

```

**예상 답변 및 해설**

- 함수 표현식에 사용된 기명 함수 `bar`는 함수 몸체 내부에서만 유효합니다.
- 변수 `func`는 함수 객체를 참조하고 있으므로 `func()`를 호출하면 정상적으로 `"Inside bar"` 가 출력됩니다.
- 그러나 외부에서 `bar()`로 호출하려고 하면, `bar`라는 식별자가 존재하지 않아서 **ReferenceError: bar is not defined** 에러가 발생합니다.

---