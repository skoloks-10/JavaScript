# 함수 part1

Date: 2025년 3월 10일
페이지: p.154~167
완료: Yes

## 함수(Function)

JavaScript에서 **함수**는 프로그램을 구성하는 핵심 단위입니다. 함수는 하나의 작업 또는 일련의 과정을 캡슐화하여, 입력을 받아 내부의 로직을 실행한 후 결과를 반환하는 코드 블록입니다.

---

## 1. 함수란?

함수에 대한 기본 개념은 다음과 같습니다:

- **정의**:
    - 함수는 여러 문장(Statements)을 하나의 실행 단위로 묶은 것입니다.
    - 입력(Arguments)을 받아 처리한 후 결과(Return Value)를 제공합니다.
- **구성 요소**:
    - **매개변수(Parameter)**: 함수 내부에서 입력 값을 받기 위해 선언된 변수입니다.
    - **인수(Argument)**: 함수를 호출할 때 전달하는 실제 값입니다.
    - **반환값(Return Value)**: 함수 실행 후 결과로 돌려주는 값입니다.
- **함수는 값이다**:
    - JavaScript에서 함수는 객체(object)입니다.
    - 이것은 함수를 변수에 할당하거나 다른 함수의 인자로 전달할 수 있음을 의미합니다.

예제를 통해 살펴보면:

```jsx
// f(x, y) = x + y 로 정의된 함수
function add(x, y) {
  return x + y;
}

// 함수 호출: add(2, 5)의 결과는 7
console.log(add(2, 5)); // 7

```

함수를 호출하면 코드 블록 내부의 문장이 실행되고, 그 결과가 반환됩니다.

---

## 2. 함수를 사용하는 이유

함수를 사용하면 많은 장점을 얻을 수 있습니다:

- **재사용성**:
    
    한 번 정의된 함수는 여러 곳에서 호출할 수 있습니다.
    
    이를 통해 동일한 로직을 반복 작성하지 않아도 됩니다.
    
- **유지보수의 용이함**:
    
    코드 중복이 줄어들어, 수정이나 버그 수정 시 한 곳만 변경하면 됩니다.
    
    이는 코드의 신뢰성과 안정성을 높입니다.
    
- **가독성 개선**:
    
    함수 이름을 통해 내부 구현을 들여다보지 않고도 함수의 역할을 파악할 수 있습니다.
    
- **실행 시점 제어**:
    
    필요한 시점에 함수를 호출하여 원하는 로직을 실행시킬 수 있습니다.
    

---

## 3. 함수 리터럴 (Function Literal)

함수는 **평가되어** 값으로 생성되는 객체입니다. 이를 함수 리터럴이라고 하며, 다음과 같이 구성됩니다:

- **`function` 키워드**
- **함수 이름**:
    - 함수 선언문에서는 반드시 이름을 명시해야 합니다.
    - 함수 표현식에서는 이름을 생략할 수 있으며, 익명 함수(Anonymous Function)로 사용할 수 있습니다.
- **매개변수 목록**:
    - 괄호 `()` 안에 0개 이상의 매개변수를 쉼표(,)로 구분하여 나열합니다.
- **함수 몸체**:
    - 중괄호 `{}`로 감싼 실행할 문장들의 집합입니다.

### 예시 1: 익명 함수 표현식

```jsx
var add = function (x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7

```

### 예시 2: 기명 함수 표현식

```jsx
var add = function foo(x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
// 아래와 같이 함수 이름으로 호출하면 에러발생:
// console.log(foo(2, 5)); // ReferenceError: foo is not defined

```

**주의**:

- **단독 사용**:
    
    함수 리터럴이 단독으로 사용되면 함수 선언문으로 해석됩니다.
    
    ```jsx
    function foo() {
      console.log('foo');
    }
    foo(); // foo 출력
    
    ```
    
- **피연산자로 사용**:
    
    함수 리터럴이 변수에 할당되거나 피연산자로 사용되면 함수 표현식으로 해석되어, 내부에서만 함수 이름(있다면)이 유효합니다.
    
    ```jsx
    (function bar() {
      console.log('bar');
    });
    // bar(); // ReferenceError: bar is not defined
    
    ```
    

---

## 4. 함수 정의 (Function Definition)

함수 정의는 매개변수, 실행할 문장, 반환값 등을 미리 지정하여 함수 객체를 생성하는 과정입니다. JavaScript에서는 여러 방식으로 함수를 정의할 수 있습니다.

### 4.1 함수 선언문 (Function Declaration)

- **특징**:
    - 함수 이름을 명시하며 정의합니다.
    - *호이스팅(Hoisting)**이 적용되어, 함수 선언문은 스크립트 시작 전에 메모리에 등록됩니다.
- **예제**:
    
    ```jsx
    // 함수 선언문
    function add(x, y) {
      return x + y;
    }
    
    // 함수 참조
    console.dir(add); // ƒ add(x, y)
    
    // 함수 호출
    console.log(add(2, 5)); // 7
    
    ```
    

> 참고: 함수 선언문은 변수에 할당할 수 없으며, 순수한 "문(statement)"입니다.
> 

---

### 4.2 함수 표현식 (Function Expression)

- **특징**:
    - 함수 리터럴을 변수, 객체의 속성, 배열 요소 등에 할당하여 사용합니다.
    - *일급 객체(First-class Citizen)**이므로, 함수 자체를 값처럼 다룰 수 있습니다.
    - 함수 표현식은 실행 시점에 평가되므로, 해당 코드가 실행될 때 함수 객체가 생성됩니다.
- **예제**:
    
    ```jsx
    // 익명 함수 표현식
    var add = function (x, y) {
      return x + y;
    };
    console.log(add(2, 5)); // 7
    
    // 기명 함수 표현식
    var add = function foo(x, y) {
      return x + y;
    };
    console.log(add(2, 5)); // 7
    
    // 함수 이름 'foo'는 함수 몸체 내부에서만 유효합니다.
    // console.log(foo(2, 5)); // ReferenceError: foo is not defined
    
    ```
    

> 함수 호이스팅의 차이:
> 
> - **함수 선언문**은 호출 전에 사용할 수 있지만,
> - **함수 표현식**은 해당 표현식이 실행된 후에만 사용 가능합니다.

예를 들어:

```jsx
console.log(add(2, 5)); // 정상 출력
console.log(sub);       // undefined
// console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};

```

---

### 4.3 Function 생성자 함수 (Function Constructor)

- **설명**:
    - `new Function()`을 사용해 문자열로 매개변수 목록과 함수 몸체를 전달하면 함수 객체가 생성됩니다.
    - 이 방식은 동적으로 함수를 생성할 수 있지만, 가독성과 성능 측면에서 권장되지 않습니다.
- **예제**:
    
    ```jsx
    var add = new Function('x', 'y', 'return x + y');
    console.log(add(2, 5)); // 7
    
    ```
    

---

### 4.4 화살표 함수 (Arrow Function)

- **특징**:
    - 간결한 문법을 제공하는 익명 함수 표현식의 한 종류입니다.
    - 항상 익명으로 정의되며, `this` 바인딩과 관련한 독특한 특성을 가집니다.
- **예제**:
    
    ```jsx
    const add = (x, y) => x + y;
    console.log(add(2, 5)); // 7
    
    ```
    

---

## 추가적으로 기억할 점

- **함수 호이스팅 (Function Hoisting)**:
    
    함수 선언문은 실행 전에 메모리에 등록되어 호출 시점과 상관없이 사용할 수 있지만, 함수 표현식은 할당문이 실행된 이후에야 사용할 수 있습니다.
    
- **일급 객체 (First-class Object)**:
    
    함수는 다른 값처럼 변수에 할당, 인자로 전달, 반환값으로 활용할 수 있습니다.
    
    이를 토대로 클로저(Closure)나 고차 함수(Higher-order Function) 등의 패턴을 구현할 수 있습니다.
    

---

이렇게 정리된 내용을 참고하면 JavaScript에서 함수를 정의하고 활용하는 다양한 방법과 그 장점을 보다 명확하게 이해할 수 있습니다.

### 더 알아보기

- **클로저(Closure)**: 함수가 자신의 렉시컬 환경(스코프)을 기억하는 개념으로, 고차 함수나 모듈 패턴에서 유용하게 사용됩니다.
- **`this`의 바인딩**: 특히 화살표 함수와 일반 함수에서 `this`가 어떻게 다른지 살펴보면, 객체지향 프로그래밍에서 많은 인사이트를 얻을 수 있습니다.
- **ES6 이후의 함수 문법**: 화살표 함수 외에도, 향상된 객체 리터럴 표기법 등 다양한 기능을 탐구해 보세요.

이 외에 궁금한 점이나 더 알고 싶은 주제가 있다면, 언제든지 질문해 주세요!

[함수 part1 퀴즈와 연습문제](%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20part1%20%E1%84%8F%E1%85%B1%E1%84%8C%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%B3%E1%86%B8%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%201b42ad07fb2080048b88f9de65ae53fd.md)