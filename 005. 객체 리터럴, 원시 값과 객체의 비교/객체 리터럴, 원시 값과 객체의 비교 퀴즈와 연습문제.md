# 객체 리터럴, 원시 값과 객체의 비교 퀴즈와 연습문제

## 퀴즈

## 퀴즈 1

**문제:**

객체 리터럴이란 무엇이며, JavaScript에서 객체 리터럴을 사용해 객체를 생성하는 기본 구문은 무엇인가요?

**정답 및 해설:**

객체 리터럴은 중괄호 `{ }` 안에 키-값 쌍을 나열하는 방식으로 객체를 직접 생성하는 방법입니다.

- **해설:**
    
    객체 리터럴은 코드를 간결하게 작성할 수 있고, 객체 생성 시점에 바로 프로퍼티와 메서드를 포함할 수 있습니다.
    
    **예제:**
    
    ```jsx
    const person = {
      name: 'Lee',
      age: 30,
      sayHello: function () {
        console.log(`Hello! My name is ${this.name}.`);
      }
    };
    
    ```
    
    위 예제에서는 `name`, `age`라는 프로퍼티와 `sayHello`라는 메서드를 가진 객체를 생성합니다.
    

---

## 퀴즈 2

**문제:**

객체에서 프로퍼티와 메서드의 차이를 설명하고, 메서드 축약 표현이 무엇인지 설명하세요.

**정답 및 해설:**

- **프로퍼티:** 객체의 상태나 데이터를 저장하는 키-값 쌍입니다.
- **메서드:** 객체의 행동을 나타내는 함수로, 객체 내에 정의되어 `this`를 통해 객체 자신에 접근합니다.
    
    **메서드 축약 표현 (ES6):**
    
    ES6부터는 객체 내 메서드를 정의할 때 `function` 키워드를 생략할 수 있습니다.
    
    **예제:**
    
    ```jsx
    // ES5 방식
    var obj1 = {
      name: 'Lee',
      sayHi: function() {
        console.log('Hi! ' + this.name);
      }
    };
    
    // ES6 방식 (메서드 축약 표현)
    const obj2 = {
      name: 'Lee',
      sayHi() {
        console.log('Hi! ' + this.name);
      }
    };
    
    ```
    
    **해설:**
    
    메서드 축약 표현을 사용하면 코드를 더 간결하게 작성할 수 있으며, 기능에 차이는 없습니다. 프로퍼티는 단순히 데이터를 저장하는 반면, 메서드는 함수 형태로 동작을 실행합니다.
    

---

## 퀴즈 3

**문제:**

다음 두 가지 프로퍼티 접근 방식인 마침표 표기법과 대괄호 표기법의 차이점은 무엇이며, 존재하지 않는 프로퍼티에 접근 시 어떤 결과가 나타나는지 설명하세요.

**정답 및 해설:**

- **마침표 표기법:** 객체의 프로퍼티에 접근할 때 `객체명.프로퍼티명` 형식으로 사용합니다.
- **대괄호 표기법:** 객체의 키가 변수로 동적으로 결정되거나 식별자 규칙에 맞지 않는 경우, `객체명['프로퍼티명']` 형식으로 사용합니다.
    
    존재하지 않는 프로퍼티에 접근할 경우, 결과는 `undefined`가 됩니다.
    
    **예제:**
    
    ```jsx
    const person = { name: 'Lee' };
    
    // 마침표 표기법
    console.log(person.name); // "Lee"
    
    // 대괄호 표기법
    console.log(person['name']); // "Lee"
    
    // 존재하지 않는 프로퍼티 접근
    console.log(person.age); // undefined
    
    ```
    
    **해설:**
    
    대괄호 표기법은 특히 계산된 프로퍼티 이름이나 동적 프로퍼티 키를 사용할 때 유용합니다. 만약 객체에 해당 키가 없다면 JavaScript는 에러를 발생시키지 않고 `undefined`로 처리합니다.
    

---

## 퀴즈 4

**문제:**

ES6에서 추가된 객체 리터럴 확장 기능 중 **프로퍼티 축약 표현**과 **계산된 프로퍼티 이름**에 대해 설명하고 예제를 작성하세요.

**정답 및 해설:**

- **프로퍼티 축약 표현:**
    
    변수와 동일한 이름의 프로퍼티 키를 선언할 때, 키와 값을 생략하여 간결하게 작성할 수 있습니다.
    
    **예제:**
    
    ```jsx
    let x = 1, y = 2;
    // 프로퍼티 축약 표현
    const obj = { x, y };
    console.log(obj); // { x: 1, y: 2 }
    
    ```
    
- **계산된 프로퍼티 이름:**
    
    대괄호 `[]` 안에 표현식을 작성하여 프로퍼티 키를 동적으로 생성할 수 있습니다.
    
    **예제:**
    
    ```jsx
    const prefix = 'prop';
    let i = 0;
    const obj2 = {
      [`${prefix}-${++i}`]: i,
      [`${prefix}-${++i}`]: i,
      [`${prefix}-${++i}`]: i
    };
    
    console.log(obj2); // { "prop-1": 1, "prop-2": 2, "prop-3": 3 }
    
    ```
    
    **해설:**
    
    이 두 기능은 객체를 생성할 때 코드의 간결성과 가독성을 크게 높여줍니다. 특히 동적 키 생성이 필요한 경우 계산된 프로퍼티 이름 기능은 매우 유용합니다.
    

---

## 퀴즈 5

**문제:**

`delete` 연산자를 사용하여 객체의 프로퍼티를 삭제하는 방법과, 존재하지 않는 프로퍼티를 삭제할 경우의 동작에 대해 설명하시고 예제를 작성하세요.

**정답 및 해설:**

- **사용법:**
    
    `delete 객체명.프로퍼티` 또는 `delete 객체명['프로퍼티']`로 해당 프로퍼티를 삭제할 수 있습니다.
    
- **존재하지 않는 프로퍼티 삭제 시:**
    
    에러 없이 아무런 동작도 발생하지 않습니다.
    
    **예제:**
    
    ```jsx
    const person = { name: 'Lee' };
    person.age = 20;
    
    // age 프로퍼티 삭제
    delete person.age;
    // address 프로퍼티는 존재하지 않지만 에러 없이 실행됨
    delete person.address;
    
    console.log(person); // { name: "Lee" }
    
    ```
    
    **해설:**
    
    `delete` 연산자를 사용하면 객체의 특정 프로퍼티가 제거되어 해당 데이터에 접근할 수 없게 됩니다. 존재하지 않는 키에 delete를 적용해도 스크립트 전체에 영향을 주지 않으므로 안전하게 사용할 수 있습니다.
    

---

아래는 원시 값과 객체의 특징에 대한 이해도를 점검할 수 있는 퀴즈입니다. 각 문제 후 해설을 포함했으니 꼭 내용을 확인해보세요.

---

## 퀴즈 1: 원시 값의 특징

**문제 1:**

다음 중 원시 값(Primitive Value)의 특징으로 옳은 것을 모두 고르세요.

1. 한 번 생성되면 내부 값이 변경되지 않는다.
2. 변수에 값을 할당하면 **실제 값**이 저장된다.
3. 재할당 시 기존 메모리의 값을 직접 수정하는 것이 아니라 새로운 값이 생성되어 저장된다.

**선택지:**

A. 1번만

B. 1번과 2번만

C. 2번과 3번만

D. 1번, 2번, 3번 모두

**정답:** D

**해설:**

원시 값은 불변(immutable)하며, 변수에 실제 값이 저장되고 재할당 시 새로운 메모리 공간에 값이 저장됩니다. 기존 값이 바뀌지 않으므로 모든 선택지가 옳습니다.

---

## 퀴즈 2: 문자열의 불변성

**문제 2:**

다음 코드를 실행했을 때 콘솔에 출력되는 결과는 무엇일까요?

```jsx
var str = 'hello';
str[0] = 'H';
console.log(str);

```

**선택지:**

A. Hello

B. hello

C. 'Hello'

D. 에러 발생

**정답:** B

**해설:**

문자열은 원시 값이며 불변성을 갖습니다. 따라서 `str[0] = 'H';`와 같이 개별 문자를 바꾸려고 해도 실제 문자열은 변경되지 않고 그대로 `'hello'`가 출력됩니다.

---

## 퀴즈 3: 객체의 참조 전달

**문제 3:**

아래 코드를 보고, 변수 `copy`가 의미하는 바를 고르세요.

```jsx
var person = { name: 'Lee' };
var copy = person;

```

**선택지:**

A. `copy`는 `person` 객체의 완전한 복제본이다.

B. `copy`는 `person`이 참조하는 동일한 객체의 **참조값**을 갖는다.

C. `copy`는 별도의 메모리 공간에 저장된 객체이다.

D. 객체는 복사할 수 없으므로 `copy`는 `undefined`다.

**정답:** B

**해설:**

객체는 변수에 저장될 때 객체의 실제 값이 아닌 객체가 저장된 메모리 주소(참조값)를 저장합니다. 따라서 `copy`에 `person`을 할당하면 동일한 객체에 대한 참조가 복사됩니다. 한 곳에서 변경하면 모두에게 반영됩니다.

---

## 퀴즈 4: 원시 값의 값 전달

**문제 4:**

다음 코드를 실행하면 콘솔에 출력되는 두 변수의 값은 무엇일까요?

```jsx
var number = 50;
var copy = number;
number = 100;
console.log(number, copy);

```

**선택지:**

A. 100, 50

B. 100, 100

C. 50, 100

D. 50, 50

**정답:** A

**해설:**

원시 값의 경우 변수에 실제 값이 저장되고, 다른 변수에 할당할 때 값이 복사됩니다. 따라서 `number`가 100으로 바뀌더라도 `copy`는 원래 값인 50을 유지합니다.

---

## 퀴즈 5: 객체의 가변성

**문제 5:**

객체의 특성으로 옳은 것을 고르세요.

**선택지:**

A. 객체는 불변성이 있어 한 번 생성하면 내부 프로퍼티를 수정할 수 없다.

B. 객체는 가변성이 있어 변수에 할당된 후에도 프로퍼티를 추가, 수정, 삭제할 수 있다.

**정답:** B

**해설:**

객체는 가변(mutable)합니다. 변수에 할당된 객체의 내부 프로퍼티는 재할당 없이도 변경할 수 있으며, 여러 변수에서 동일한 객체에 접근 시 한 곳에서의 변경이 다른 변수에 영향을 미칩니다.

---

## 부가 정보

- **깊은 복사(Deep Copy) vs 얕은 복사(Shallow Copy):**
    
    객체의 참조 복사를 다루면서 한 변수의 변경이 다른 변수에 영향을 주는 문제를 해결하기 위해 깊은 복사와 얕은 복사의 개념을 학습해보면 좋습니다.
    
- **불변성을 유지하는 방법:**
    
    자바스크립트에서는 객체의 불변성을 유지하기 위해 `Object.freeze()`와 같은 방법이나, 불변 데이터 구조를 사용하여 상태 관리 시 예기치 않은 부수효과를 막을 수 있습니다.
    

## 연습문제

## 연습문제 1: 객체 생성 및 프로퍼티 접근

**문제 설명:**

1. 객체 리터럴을 사용하여 `student`라는 객체를 생성하세요.
    - `student` 객체는 다음 프로퍼티를 포함해야 합니다:
        - `name`: `"Kim"`
        - `age`: `25`
2. 생성한 객체의 프로퍼티 `name`과 `age`에 접근하여 콘솔에 출력해보세요.
    - **조건:** 마침표 표기법과 대괄호 표기법을 각각 한 번씩 사용합니다.

**예시 출력:**

```
Kim
25

```

---

## 연습문제 2: 메서드 추가 및 호출

**문제 설명:**

1. 위에서 생성한 `student` 객체에 `introduce`라는 메서드를 추가하세요.
    - 이 메서드는 `"Hello, my name is [name]"` (예를 들어 `"Hello, my name is Kim"`)를 콘솔에 출력해야 합니다.
2. 작성한 메서드를 호출하여 올바른 메시지가 출력되는지 확인합니다.

---

## 연습문제 3: 프로퍼티 축약 표현 활용

**문제 설명:**

1. 변수 `major`와 `gpa`를 각각 선언하고,
    - `major`에 `"Computer Science"`,
    - `gpa`에 `3.9`를 할당합니다.
2. 객체 리터럴의 프로퍼티 축약 표현을 사용하여,
    - 변수 이름과 동일한 프로퍼티 키를 갖는 객체 `studentDetails`를 생성하세요.
3. 최종 생성된 객체를 콘솔에 출력하여 확인합니다.

**예시 객체:**

```
{
  major: "Computer Science",
  gpa: 3.9
}

```

---

## 연습문제 4: 계산된 프로퍼티 이름 사용

**문제 설명:**

1. 변수 `subject`에 `"math"` 값을 저장하세요.
2. 계산된 프로퍼티 이름을 활용하여,
    - 객체 리터럴 내에 `[subject]` 프로퍼티가 `100`이라는 값을 가지도록 객체를 생성합니다.
3. 생성된 객체를 콘솔에 출력해 결과를 확인하세요.

**예시 객체:**

```
{
  math: 100
}

```

---

## 연습문제 5: 프로퍼티 동적 추가와 삭제

**문제 설명:**

1. 기존의 `student` 객체에 동적으로 `hobby` 프로퍼티를 추가해서 `"reading"`이라는 값을 할당하세요.
2. 추가된 `hobby` 프로퍼티가 잘 반영되었는지 콘솔에 출력해 확인하세요.
3. 이후 `delete` 연산자를 사용해 `hobby` 프로퍼티를 삭제하고, 객체를 다시 출력해 변화가 있는지 확인합니다.

---

### 추가 연습문제: 객체 리터럴의 확장 기능 종합활용

**문제 설명:**

ES6의 객체 리터럴 확장 기능들을 모두 사용하여 아래 문제를 해결해 보세요.

1. 변수 `firstName`과 `lastName`에 각각 `"John"`과 `"Doe"`를 할당합니다.
2. 또한, 변수 `score`에 `95`를 할당합니다.
3. 계산된 프로퍼티 이름을 활용하여 `subject` 변수를 `"science"`로 선언하고,
이를 기반으로 `[subject + "Score"]` 형태의 프로퍼티를 가진 객체를 생성하세요.
4. 최종적으로 다음 구성 요소들을 포함하는 `profile` 객체를 작성합니다.
    - 프로퍼티 축약 표현으로 `firstName`과 `lastName`
    - 메서드 축약 표현으로 `getFullName()`를 추가하여 `"John Doe"`를 반환하도록 함
    - 계산된 프로퍼티 이름으로 `"scienceScore"` 키에 `score` 값을 할당

**예시 코드 구조:**

```
const firstName = "John";
const lastName = "Doe";
const score = 95;
const subject = "science";

const profile = {
  firstName,
  lastName,
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  // 계산된 프로퍼티 이름 사용
  [subject + "Score"]: score,
};

console.log(profile.getFullName()); // "John Doe"
console.log(profile.scienceScore);   // 95

```

---

다음은 원시 값과 객체의 특징 및 전달 방식을 이해했는지 확인할 수 있는 연습문제 모음입니다. 각 문제는 코드 분석, 실행 결과 예측, 그리고 그 이유를 설명하는 방식으로 구성되어 있습니다.

---

## 연습문제 1: 원시 값의 복사와 재할당

**문제:**

아래 코드를 실행하면 출력되는 결과는 무엇이며, 그 이유는 무엇인가요?

```
let num1 = 42;
let num2 = num1;
num1 = 100;
console.log(num1, num2);

```

**예상 답안:**

출력 결과는 `100 42`입니다.

**해설:**

- `num1`에 42가 할당될 때 실제 숫자 값 42가 변수에 저장됩니다.
- `num2 = num1;`에서 num1의 값(42)이 복사되어 num2에 저장됩니다.
- 이후 `num1 = 100;`으로 num1에 새로운 값 100이 할당되더라도 num2는 여전히 초기값 42를 유지합니다.
- 이는 원시 값이 **값에 의한 전달**(pass by value)되기 때문입니다.

---

## 연습문제 2: 객체의 참조와 변경

**문제:**

다음 코드를 실행한 후, `console.log(car.model);`의 출력 결과를 예측하고 설명하세요.

```
let car = { brand: "Toyota", model: "Corolla" };
let myCar = car;
myCar.model = "Camry";
console.log(car.model);

```

**예상 답안:**

출력 결과는 `"Camry"`입니다.

**해설:**

- 객체는 변수에 **참조값**(메모리 주소)을 저장합니다.
- `let myCar = car;`에서 `myCar`는 car가 가리키는 동일한 객체의 참조를 갖게 됩니다.
- `myCar.model = "Camry";` 라인에서 객체 내부의 `model` 프로퍼티가 변경되면, car와 myCar 모두 동일한 객체를 참조하므로 그 변경 사항이 반영됩니다.

**추가연습:**

아래 코드를 실행하면 어떤 결과가 나올까요?

```
let car = { brand: "Toyota", model: "Corolla" };
let myCar = car;
myCar = { brand: "Honda", model: "Civic" };
console.log(car.model);

```

**포인트:**

`myCar`에 새로운 객체를 할당하면, car가 참조하는 원래의 객체는 그대로 남습니다. 따라서 출력 결과는 `"Corolla"`입니다.

---

## 연습문제 3: 문자열의 불변성

**문제:**

다음 코드를 실행했을 때 콘솔에 출력되는 결과를 예측해보세요.

```
let greeting = "hello";
greeting[0] = "H";
console.log(greeting);

```

**예상 답안:**

출력 결과는 `"hello"`입니다.

**해설:**

- 문자열은 원시 값으로 **불변(immutable)** 입니다.
- 개별 문자를 수정하려고 하더라도, 실제 문자열은 변경되지 않습니다.
- 단, 변수에 재할당을 하면 완전히 새로운 문자열이 만들어집니다.

---

## 연습문제 4: `const`로 선언된 객체와 내부 프로퍼티 변경

**문제:**

다음 코드를 실행한 결과를 예측하고, 왜 그런지 설명하세요.

```
const user = { name: "Alice" };
user.age = 30;
console.log(user);

```

**예상 답안:**

출력 결과는 `{ name: "Alice", age: 30 }`입니다.

**해설:**

- `const`로 선언된 변수는 **재할당이 불가능**하지만, 객체 내부의 프로퍼티는 변경할 수 있습니다.
- 즉, user 자체를 완전히 다른 객체로 바꿀 수는 없으나, user가 참조하는 객체의 프로퍼티는 추가 및 수정할 수 있습니다.

**추가연습:**

만약 아래와 같이 코드를 작성하면 무엇이 발생할까요?

```
user = { name: "Bob" };

```

**답변:**

`TypeError: Assignment to constant variable.`

즉, `const` 변수에 재할당을 시도하면 오류가 발생합니다.

---

## 연습문제 5: 얕은 복사와 깊은 복사

**문제:**

다음 코드를 실행하면 `personCopy.address.city`의 값은 무엇이 출력될까요? 그리고 그 이유를 설명하세요.

```
let person = {
  name: "Bruce",
  address: { city: "Gotham" }
};

let personCopy = { ...person }; // Spread operator를 통한 얕은 복사
person.address.city = "Metropolis";
console.log(personCopy.address.city);

```

**예상 답안:**

출력 결과는 `"Metropolis"`입니다.

**해설:**

- Spread operator `{ ...person }`는 최상위 속성만 복사하는 **얕은 복사**를 수행합니다.
- 따라서, `person` 객체의 `address`와 같이 중첩된 객체들은 동일한 참조값을 공유합니다.
- 결과적으로, 원본 person 객체의 중첩 객체 프로퍼티가 변경되면, personCopy에서도 그 변경이 반영됩니다.

**추가연습:**

**깊은 복사(Deep Copy)**를 통해 중첩된 객체까지 독립적으로 복사하려면 아래와 같이 작성할 수 있습니다.

```
let personDeepCopy = JSON.parse(JSON.stringify(person));
person.address.city = "Star City";
console.log(personDeepCopy.address.city); // "Metropolis" 혹은 원래의 값

```

---

## 연습문제 6: 원시 값과 객체의 메모리 참조

**문제:**

아래 코드를 실행할 때 각 변수에 저장되는 값과 메모리 참조 관계를 설명한 후, 출력 결과를 예측하세요.

```
let x = 10;
let y = x;
let z = { value: x };
x = 20;
console.log(x, y, z.value);

```

**예상 답안:**

출력 결과는 `20 10 10`입니다.

**해설:**

- `x`와 `y`는 원시 값(숫자)를 저장하므로, y에 x의 초기값 10이 복사됩니다. 이후 x가 20으로 변경되어도 y는 영향을 받지 않습니다.
- `z`는 객체이고, 객체의 프로퍼티 `value`에 원시 값 10이 저장됩니다. x의 변경은 z 내부에 저장된 값에 영향을 주지 않습니다.

---

## 연습문제 7: 객체 내부 배열의 참조

**문제:**

아래 코드를 실행하면 출력되는 결과는 무엇인가요? 그리고 그 이유를 설명하세요.

```
let obj1 = { data: [1, 2, 3] };
let obj2 = obj1;
obj2.data.push(4);
console.log(obj1.data, obj2.data);

```

**예상 답안:**

출력 결과는 `[1, 2, 3, 4] [1, 2, 3, 4]`입니다.

**해설:**

- `obj1`과 `obj2`는 동일한 객체의 참조를 공유합니다.
- 따라서, `obj2.data.push(4);`를 통해 배열에 요소를 추가하면, 이 변경 사항은 두 변수 모두에 반영됩니다.

---